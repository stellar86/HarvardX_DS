---
title: "Bitcoin Analysis and Forecasting"
author: "Estelle Rossouw [github](https://github.com/stellar86/HarvardX_DS/tree/master/Bitcoin%20Analysis%20and%20Forecast)"
date: "`r format(Sys.time(), '%d %B %Y')`"
abstract: |
  This is a Bitcoin analysis and forecasting report for the Harvard-X Data Science Capstone Project.
header-includes:
  - \usepackage{booktabs}
  - \usepackage{longtable}
  - \usepackage{array}
  - \usepackage{multirow}
  - \usepackage{wrapfig}
  - \usepackage{float}
  - \usepackage{colortbl}
  - \usepackage{pdflscape}
  - \usepackage{tabu}
  - \usepackage{threeparttable}
  - \usepackage[normalem]{ulem}
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
    df_print: kable
    highlight: pygments
    keep_tex: true
  html_document: default
---

```{r setup, include=TRUE, echo=FALSE}
library(knitr)
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=40),tidy=FALSE,echo = TRUE, cache=FALSE, warning = FALSE,message = FALSE, fig.align = 'center')
#tinytex::install_tinytex()
```

```{r, echo=FALSE}
################################################################################################################################
# INSTRUCTIONS - ENSURE THAT crypto-markets.csv ARE IN THE SAME DIRECTORY AS THE .R FILE AND .RMD FILE
# FILE CAN BE DOWNLOADED WITH A REGISTERED ACCOUNT FROM: https://www.kaggle.com/jessevent/all-crypto-currencies
# Ensure that you have internet access for installing libraries!
# Installing libraries can take 30 minutes
# Set working directory to local path on computer (line106 in .R and line140 in .RMD)
# Install Tinytex if required: install_tinytex() -- accept DLL error missing (Can be done on line 33)
################################################################################################################################

################################################################################################################################
# Install Required Libraries
################################################################################################################################
if(!require(readr)) install.packages("readr")
if(!require(dplyr)) install.packages("dplyr")
if(!require(tidyr)) install.packages("tidyr")
if(!require(stringr)) install.packages("stringr")
if(!require(ggplot2)) install.packages("ggplot2")
if(!require(ggplot2)) install.packages("plotly")
if(!require(gridExtra)) install.packages("gridExtra")
if(!require(dslabs)) install.packages("dslabs")
if(!require(data.table)) install.packages("data.table")
if(!require(ggrepel)) install.packages("ggrepel")
if(!require(ggthemes)) install.packages("ggthemes")
if(!require(Metrics)) install.packages("Metrics")
if(!require(lubridate)) install.packages("lubridate")
if(!require(caret)) install.packages("caret")
if(!require(forcats)) install.packages("forcats")
if(!require(kableExtra)) install.packages("kableExtra")
if(!require(formatR)) install.packages("formatR")
if(!require(forecast)) install.packages("forecast", dependencies = TRUE)
if(!require(tseries)) install.packages("tseries")
if(!require(scales)) install.packages("scales")
if(!require(anytime)) install.packages("anytime")
if(!require(bsts)) install.packages("bsts")
if(!require(car)) install.packages("car")
if(!require(keras)) install.packages("keras")
if(!require(MCMCpack)) install.packages("MCMCpack")
if(!require(smooth)) install.packages("smooth")
if(!require(tensorflow)) install.packages("tensorflow")
if(!require(tseries)) install.packages("tseries")
if(!require(TTR)) install.packages("TTR")
if(!require(fpp2)) install.packages("fpp2")
if(!require(AnalyzeTS)) install.packages("AnalyzeTS")
if(!require(arm)) install.packages("arm")
if(!require(corrplot)) install.packages("corrplot")
if(!require(kernlab)) install.packages("kernlab")
if(!require(gam)) install.packages("gam")
if(!require(randomForest)) install.packages("randomForest")
if(!require(tinytex)) install.packages("tinytex")

################################################################################################################################
# Load Required Libraries
################################################################################################################################

library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(gridExtra)
library(dslabs)
library(data.table)
library(ggrepel)
library(ggthemes)
library(Metrics)
library(lubridate)
library(forcats)
library(knitr)
library(kableExtra)
library(formatR)
library(forecast)
library(tseries)
library(scales)
library(grid)
library(anytime)
library(bsts)
library(car)
library(forecast)
library(keras)
library(MCMCpack)
library(smooth)
library(tseries)
library(TTR)
library(fpp2)
library(caret)
library(AnalyzeTS)
library(arm)
library(corrplot)
library(kernlab)
library(gam)
library(randomForest)
library(tinytex)

options(knitr.table.format = "latex")

################################################################################################################################
# Create Crypto Data Sets
################################################################################################################################
#Crypto currency History Dataset can be downloaded fromhttps://www.kaggle.com/jessevent/all-crypto-currencies - crypto-markets.csv

#Create Datasets

# set the working directory to the main folder containing the project files
setwd( "D:/Google Drive/Personal/Edx/edx-dl-master/Downloaded/Capstone Project/Cryptos_Final/" )

#Ensure crypto-markets.csv is in the same directory as R file
data_all_markets <- read.csv('crypto-markets.csv')

#Create Bitcoin dataset for prediction
data_bitcoin <- data_all_markets %>% filter(symbol == 'BTC')

################################################################################################################################
# Global Functions
################################################################################################################################
#Styling for kable tables
kable_table <- function(data = NULL, titlex = NULL)
{
    kable(data,format="latex") %>%
    kable_styling(bootstrap_options = c("striped", "hold_position"),
                  position = "center",
                  font_size = 10,
                  full_width = FALSE) %>%
    footnote(general = titlex,
             footnote_as_chunk = T)
 }

#Convert difference between nth and (n-1)th element

convertPercent <- function(data){
  data= diff(data)/data[-NROW(data)] * 100
  return(data)
}

#RMSE Function for Analysis

RMSE <- function(true_ratings = NULL, predicted_ratings = NULL) {
  sqrt(mean((true_ratings - predicted_ratings)^2))
}
```
\newpage
# Executive Summary

In the 17th and 18th centuries, the Dutch pioneered several financial innovations that lay the foundations for modern financial systems across the globe. First came government bonds, then the actual capital market, better known as the stock market. The Dutch East India Company became the first to issue bonds and shares to the general public in the 1600's. Stock trading emerged in 1602 in company stocks on the Amsterdam Stock Exchange. Stock market's enables companies to raise money through public investment, with rising stock prices associated with increased investment and vice versa.

Central banking systems uses fiat currencies to transfer money electronically from one account to another. This presents two problems to the account holder, i.e. high banking fees and the time it takes to complete the transaction. Due to globalisation of industries, a mechanism was required to securely transfer money from one user to another across the globe, with minimal fees and a reduced transaction time. In 1983, electronic money, e-cash, was developed by David Chaum. He further developed Digicash in 1995, by incorporating cryptography into electronic payments. Various developments resulted in the first crypto currency developed in 2009 by Satoshi Nakamototo. Crypto currencies can solve the problem of borderless secure money transfer (just to name one application!). 

Crypto currencies are decentralized digital assets which uses cryptography to secure financial transactions, the creation of additional units and verifying the transfer has taken place. Decentralization is a distributed-technology, consisting of a decentralized ledger with peer-to-peer transactions. This is basically a public database for financial transactions. 

In 2009, Bitcoin was the first developed crypto currency and available for public trading on crypto exchanges (similar to stock exchanges). Variants of Bitcoin, namely altcoins, has been developed since 2009 and there is currently more than 6000 altcoins available on various exchanges for the public to trade. Investment in crypto currencies has been chosen by crypto enthusiasts, due to the staggering gains that was yielded since it's inception.

This report describes a various machine learning algorithms and Bitcoin price forecasting techniques using the cryptocurrencypricehistory datasets available on www.kaggle.com. The datasets consists of time-series trading data for various crypto currencies. This time-series datasets will be used for future price prediction by using publically available forecasting libraries in r.

The key metric for the machine learning models being tested is the Root Mean Squared Error (RMSE) value, with the best model yielding an RMSE of 57.83 on the price of Bitcoin.

The RMSE formula used in this report:
$$\mbox{RMSE} = \sqrt{\frac{1}{n}\sum_{t=1}^{n}e_t^2}$$

To achieve the lowest possible RMSE, various algorithms was tested on a test and training set created from the main dataset.

The forecasting models uses the Mean absolute scaled error (MASE) indicator to evaluate it's accuracy.

This report consist of the following sections:
\newline Section 2: Initial Dataset Exploration
\newline Section 3: Feature Engineering/Data Cleansing
\newline Section 4: Data Analysis
\newline Section 5: Methods/Analysis
\newline Section 6: Results
\newline Section 7: Conclusion
\newline Section 8: References
\newline Section 9: Environmental Variables

\newpage

# Initial Dataset Exploration

The datasets used for this project was downloaded from https://www.kaggle.com/jessevent/all-crypto-currencies. 
The dataset consists of a .csv file with trading data for all the crypto currencies from 2010 - 2018 (dependant on when a crypto currency was released). The csv file needs to be download and saved into the same directory as the .R and .RMD file.

Initial data exploration of crypto datasets are discussed in the sections below.

## Check Dataset Composition

**First 5 rows of data_all_markets Dataset**
```{r, echo=FALSE}
#Check Dataset Composition
kable(head(data_all_markets,5)) %>%
  kable_styling(bootstrap_options = "striped", font_size = 8,full_width = F , position ="left",latex_options="scale_down") %>%
  footnote(general = "All Cryptos Columns Overview",
           footnote_as_chunk = T)
```

**Dataset Features/Variables/Columns**
```{r, echo=FALSE}
#Data Frame Structure Overview
glimpse(data_all_markets)
```
The variables can be described as follows:

**Observations: 942,000 Variables: 13 Crypto Tokens: 2,071**

- All historic open, high, low, close values for all cryptocurrencies (Data current as of 21 May 2018).
- slug: Crypto Currency
- symbol: Ticker for Crypto Currency
- name: Crypto Currency
- date: Transaction date
- ranknow: Rank of Crypto Currency for specific date
- open: Opening Price in USD
- high: Highest price over 24 Hours in USD
- low: Lowest price over 24 Hours in USD
- close: Closing Price for day in USD
- volume: Volume for day
- market: Market cap for day
- close_ratio: Daily close rate, min-maxed with the high and low values for the day. 
- spread: $USD difference between the high and low values for the day.

The data set has been identified as an univariate time series which consists of single (scalar) observation recorded sequentially over equal time increments (in this case, daily).

\newpage
## Check Dataset For NA's
**data_all_markets dataset**

```{r, echo=FALSE}
#Check if NA's exist in data sets
data_all_markets_na <- sapply(data_all_markets, function(x) sum(is.na(x)))
kable_table(data_all_markets_na,"Check NA's data_all_markets Dataset")
```
**data_bitcoin dataset**

```{r, echo=FALSE}
data_bitcoin_na <- sapply(data_bitcoin, function(x) sum(is.na(x)))
kable_table(data_bitcoin_na,"Check NA's data_bitcoin Dataset")
```

This indicates that no records needs to be removed (for the accuracy and operation of the algorithm)

\newpage

# Feature Engineering/Data Cleansing

The aim of feature engineering or data cleansing is to modify (add/delete/update) existing columns in the datasets to provide the required functionality for the machine learning algorithm

## Date Format
As identified in the exploratory data analysis section, the date column is in factor format. Converting this column to a character field will enable for ease of data analysis.
```{r, echo=TRUE}
#Convert date from factor to character
data_all_markets$date <- ymd(as.character(data_all_markets$date))
data_bitcoin$date <- ymd(as.character(data_bitcoin$date))
```
The resultant summary for both datasets are as follows: 
```{r, echo=FALSE}
glimpse(data_all_markets)
```

```{r, echo=FALSE}
glimpse(data_bitcoin)
```

\newpage
## Extracting Year, Month and Day of Price
From the new converted date column, the year, month and day of the currency price can be extracted for data analysis and algorithm feature addition.
```{r, echo=TRUE}
# Extract the year and month and day of crypto currency price
data_all_markets$priceYear <- format(data_all_markets$date,"%Y")
data_all_markets$priceMonth <- format(data_all_markets$date,"%m")
data_all_markets$priceDay <- format(data_all_markets$date,"%d")

data_bitcoin$priceYear <- format(data_bitcoin$date,"%Y")
data_bitcoin$priceMonth <- format(data_bitcoin$date,"%m")
data_bitcoin$priceDay<- format(data_bitcoin$date,"%d")
```
```{r, echo=FALSE}
glimpse(data_all_markets)
glimpse(data_bitcoin)
```
## Convert Slug, Symbol and Name to Character Fields
The slug, symbol and name fields will be converted to character fields to ensure conformatiry accross column types.
```{r, echo=TRUE}
#Convert slug,symbol and name to character fields
data_all_markets$slug <- as.character(data_all_markets$slug)
data_all_markets$symbol <- as.character(data_all_markets$symbol)
data_all_markets$name <- as.character(data_all_markets$name)

data_bitcoin$slug <- as.character(data_bitcoin$slug)
data_bitcoin$symbol <- as.character(data_bitcoin$symbol)
data_bitcoin$name <- as.character(data_bitcoin$name)
```
```{r, echo=FALSE}
glimpse(data_all_markets)
glimpse(data_bitcoin)
```
\newpage
# Data Analysis
The aim of the data analysis was to obtain a better picture on the type of data available in the dataset. Some useful insights were gained on the number of crypto's, top 20 crypto's by market capitalization, price actions and price history.

## General
Data accurate to 21 May 2018.

**Number of unique Crypto Currencies**

Based on the dataset, the number of unique crypto currencies are:
```{r,echo=FALSE}
#Get Unique nr of crypto currencies in dataset
kable_table(length(unique(data_all_markets$symbol)),"Nr of Unique Crypto Currencies")
```
**Top 20 Cryptos per Market Capitalization**

From the graph below, Bitcoin was still the top crypto to invest in based on market Capitalization
```{r,echo=FALSE}
#Top 20 Crypto Currencies by Market Cap
data_all_markets %>% group_by(name) %>% summarise(market_cap = max(market)) %>% arrange(desc(market_cap)) %>% slice(1:20) %>% 
  ggplot(aes(x = reorder(name, -market_cap), y = market_cap)) + theme_economist_white() + geom_bar(stat = "identity") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 9)) +
  labs(title = "Market Capitalization of Top 20 Crypto's",
       x = "Crypto Currency",
       y = "Market Cap")
```
\newpage
**Top 5 Cryptos Price Action over Time**

From the graph below, the price actoim for the top 5 cryptos increased rapidly from 2017 to the start of 2018. Bitcoin was the first crypto currency to "break out", followed by the rest of the altcoins. From this data, Bitcoin can be seen as the leading indicator for price movement (meaning if the price of Bitcoin goes up, there is a big probability that the prices of other altcoins will also go up, with a delayed effect).
```{r,echo=FALSE}
#Top 5 Crypto Currencies - Price Action over Time
data_all_markets %>% dplyr::select(close,name,date) %>% filter(name %in% c("Bitcoin","Ethereum","XRP","Bitcoin Cash","Cardano")) %>% 
  ggplot(aes(date,close,color = name)) + geom_line() + 
  theme(legend.position = "bottom",legend.text = element_text(size = 8, colour = "black")) +   
  labs(title = "Price Action of Top 5 Crypto's over Time",
       x = "Date",
       y = "Price USD")
```
\newpage
**Top 5 Cryptos Market Capitalization over Time**

From the graph below indicates the market Capitalization over time for the top 5 crypto currencies. Bitcoin has the highest market cap.
```{r,echo=FALSE}
#Top 5 Crypto Currencies - Market Capitalization over Time
data_all_markets %>% dplyr::select(market,name,date) %>% filter(name %in% c("Bitcoin","Ethereum","XRP","Bitcoin Cash","Cardano")) %>% 
  ggplot(aes(date,market,color = name)) + geom_line() + theme(legend.position = "bottom",legend.text = element_text(size = 8, colour = "black")) +
  labs(title = "Market Capitalization of Top 5 Crypto's over Time",
       x = "Date",
       y = "Market Capitalization")
```
\newpage
## Bitcoin Specific Analysis

This section focusses on data analysis for Bitcoin only.

**Price Action vs Market Capitalization for Bitcoin**

From the graph below, the price per Bitcoin (in USD) is directly related to the market Capitalization.
```{r,echo=FALSE}
#Price Action vs Market Capitalization for Bitcoin
data_all_markets %>% dplyr::select(market,close,name,date) %>% filter(name %in% c("Bitcoin")) %>% 
  ggplot(aes(market,close)) + geom_point() + geom_smooth(method = 'gam') + 
  theme_economist_white() +   
  labs(title = "Price Action vs Market Cap for Bitcoin",
       x = "Market Capitalization",
       y = "Bitcoin Price USD")
```
\newpage
**Determine Up and Down Months**

From the graph below, the up and down months are investiaged over time using the difference in open and closing spread per month. The limit for the spread is > 0 (indicating an up month). No pattern exists.
```{r,echo=FALSE}
#Investigate Up and Down Months Bitcoin Price
data_bitcoin %>% group_by(priceYear, priceMonth) %>% summarise(open = first(open), close = last(close), spread = last(close) -  first(open)) %>% 
  ggplot(aes(priceMonth,spread, colour = spread > 0)) + geom_point() + facet_grid(priceYear ~ .) + theme(legend.position = "bottom",legend.text = element_text(size = 8, colour = "black")) +
  labs(title = "Up and Down Months",
       x = "Date",
       y = "Spread USD")
```
\newpage
**Investigate Price Volatility of 2018**

From the graph below for the daily spread (difference between start and closing price per day) of Bitcoin price, the price is extremely volatile making it a high risk investment.
```{r,echo=FALSE}
#Investigate Price Volatility in Bitcoin
data_all_markets %>% dplyr::select(market,spread,name,date,priceYear) %>% filter(name %in% c("Bitcoin") & priceYear == 2018 ) %>% 
  ggplot(aes(date,spread)) + geom_line() + 
  theme_economist_white() +   
  labs(title = "Price Volatility using Spread (2018)",
       x = "Date (2018)",
       y = "Bitcoin Spread USD")
```
\newpage
**Classical Seasonal Decomposition by Moving Averages for Bitcoin**

The decompose function in r enables decomposition of a time series into seasonal, trend and irregular components using moving averages (aditive or multiplicative seasonal component). 

The function uses the following formulas:

Additive Model:

$$Y_{t} = T_t + S_t + e_t$$
Multiplicative model  Model:

$$Y_{t} = T_tS_te_t$$

The graph below indicates the following:
\newline Trend: trend from observed data by using moving averages. The overall trend is upwards.
\newline Seasonal: computed by averaging, for each time unit, over all periods. The selected frequency is 365.25 (one year). The seasonal trend indicates that the market cycle is up and down and repeats itself.
\newline Random: the remainder part
```{r,echo=FALSE}
#Determine trends and variability for time series data by decomposition of the time series data
#Create data set with the correct columns for the xts and ts functions
ts_data <- data_bitcoin %>% dplyr::select(date,open,high,low,close)
#Sort data by date
ts_data_sorted  <- xts(ts_data[, -1], order.by = (ts_data$date))
#Create Time-Series object since 2013
tsr_per <- ts(ts_data_sorted [,4], frequency = 365.25,start = c(2013,4,27))

#Determine Classical Seasonal Decomposition by Moving Averages
dec_tsr <- decompose(tsr_per) #Obtaining the trends and seasonality
plot(dec_tsr)
```
\newpage
**Determine if pattern exists for uptrend using the spread**

Using the spread column (difference between start and closing price per day), the graph below tries to identify an uptrend pattern for specific days using a spread cut-off of 500USD. As seen below, there is no pattern that repeats itself.
```{r,echo=FALSE}
#Try to establish which are uptrend days
data_bitcoin %>% filter(priceYear >= 2018) %>% ggplot(aes(x=priceDay, y=spread, colour = spread > 500)) + facet_grid(priceMonth ~ .) +
  geom_point() + theme(legend.position = "bottom",legend.text = element_text(size = 8, colour = "black")) +
  labs(title = "Spread per day for 2018",
                      x = "Day",
                      y = "Spread USD")
```
\newpage
**Estimate Price Change based on changes in Market Cap**

Using linear regression (lm), the price increase of one Bitcoin vs changes in market cap can be determined. The intercept is 6.432, which predicts the price of one bitcoin when the total market cap is 0 (i.e \$6.432). The slope of 5.873 indicates that the average predicted price of Bitcoin will increase by \$5.8 for every \$1 increase in total Bitcoin circulation supply.

```{r,echo=TRUE}
#Determine $ increase in price based on market cap

doll_inc <-lm(close~market, data=data_bitcoin)
summary(doll_inc)
```
\newpage
## Distributions

**Normal Distribution Fit Test**

From the QQ-Plot below, the distribution of the bitcoin data is not normal. We are thus using an univariate time series (with a single time-dependent variable).
```{r,echo=FALSE}
#Test Distribution's fit to normal distribution
qplot(data_bitcoin$volume, data_bitcoin$close) + ggtitle("Volume vs Closing Price") + theme_economist_white()
```
\newpage
**Correlation Plot**

The correlation plot below shows the correlation between the closing price, volume, market cap, close_ratio and spread. The close_ratio is a calculation from different variables, hence 0 correlation.
```{r}
#Determine Correlation between price, volume and market cap,close_ratio and spread
cor_set <- cor(data_bitcoin[,9:13])
corrplot::corrplot(cor_set, method =  "color")
```
\newpage
**Auto-Correlation Test**

The Auto-Correlation test shows that the relationship between the closing price and market cap. Seeing that the ACF does not fail within the 0 band below, there is correlation between the closing price and the market cap and limited randomness.
```{r,echo=FALSE}
#Determine correlation between closing price and market cap
ACFdata <- data_bitcoin %>% dplyr::select(close,market)
btc_acf <- acf(ACFdata, na.action=na.pass, plot=FALSE)
str(btc_acf)
plot(btc_acf)
```

\newpage
# Methodology

This section describes the machine learning and forecasting methodology followed.

## Modelling Approach

Due to the dataset being a univariate time-series, the following modelling approaches will be followed:

- glm, svmLinear, knn, gamLoess,rf,bayesglm
- Tuned gamLoess
- Tuned random forest (rf)
- ARIMA (Autoregressive Integrated Moving Average)
- Forecasting using various methods

## Training and Test Data Sets
A training and test data set was created with a 80%/20% split for the machine learning algorithm.
```{r, echo=TRUE}
set.seed(1, sample.kind="Rounding")

#Create smaller dataset for training and testing models
test_index<-sample(1:nrow(data_bitcoin),0.80*nrow(data_bitcoin), replace=FALSE)
train_set <- data_bitcoin[test_index,]
test_set <- data_bitcoin[-test_index,]

#Check if NA's exist in data sets
train_set_na <- sapply(train_set, function(x) sum(is.na(x)))
kable_table(train_set_na,"Check NA's train_set Dataset")
```
\newpage
```{r, echo=TRUE}
test_set_na <- sapply(test_set, function(x) sum(is.na(x)))
kable_table(test_set_na,"Check NA's test_set Dataset")
```
\newpage
## Machine Learning Algorithms

### Model 1: Predicting Values from Various Models in Caret Package
The first approach is to determine whether the "glm", "svmLinear", "knn", "gamLoess","rf" models in the caret package can actually predict an exact price when trained against the market cap predictor.

```{r,echo=FALSE}
##################################Investigate Different of models##################################
set.seed(1, sample.kind="Rounding")
models <- c("glm", "svmLinear", "knn", "gamLoess","rf","bayesglm")

set.seed(1, sample.kind="Rounding")

fits <- lapply(models, function(model){ 
  print(model)
  caret::train(close ~ market, method = model, data = train_set)
}) 

names(fits) <- models

#Predict Values on test_set
pred <- sapply(fits, function(object) 
  predict(object, newdata = test_set))

#Determine Accuracy
acc <- colMeans(pred == test_set$close)

#Print Accuracy
kable_table(acc,"Accuracy of various Models")
```

Based on the results table, the different algorithms are able to predict a value, but not the exact same value as in the test set (hence the accuracy of 0).

If RMSE is used as a prediction accuracy metric, the results is as follows:
```{r,echo=FALSE}
#Determine RMSE's
glm_rmse <-  RMSE(pred[,1],test_set$close)
svmLinear_rmse <-  RMSE(pred[,2],test_set$close)
knn_rmse <-  RMSE(pred[,3],test_set$close)
gamLoess_rmse <-  RMSE(pred[,4],test_set$close)
rf_rmse <-  RMSE(pred[,5],test_set$close)
bays_rmse <-  RMSE(pred[,6],test_set$close)

#Create Data Frame for RMSE's
rmse_results <- data.frame(Dataset = "Train/Test", Model="glm", RMSE=glm_rmse)
rmse_results <- rmse_results %>% add_row(Dataset = "Train/Test", Model="svmLinear",RMSE = svmLinear_rmse)
rmse_results <- rmse_results %>% add_row(Dataset = "Train/Test", Model="knn",RMSE = knn_rmse)
rmse_results <- rmse_results %>% add_row(Dataset = "Train/Test", Model="gamLoess",RMSE = gamLoess_rmse)
rmse_results <- rmse_results %>% add_row(Dataset = "Train/Test", Model="rf",RMSE = rf_rmse)
rmse_results <- rmse_results %>% add_row(Dataset = "Train/Test", Model="bayesglm",RMSE = bays_rmse)

#Print RMSE's
kable_table(rmse_results,"RMSE of Various Models")
```

From the results above, the gamLoess and random forest methods yield the best prediction of the Bitcoin price (gamLoess = 57.83USD and Random Forest = 61.62USD). The RMSE might seem high, but the Bitcoin price range was between 0-16000USD, so 60USD RMSE is not that bad!

\newpage
The graphs belows shows the actuals vs predicted values for the Random Forest and gamLoess Models:
```{r,echo=FALSE}
#Plot Random Forest VS Actuals
#Create Dataframes for plotting 
res_df <- data.frame(name = "rf", close = pred[,5], id = 1:nrow(test_set) )
bitcoin_cls_test <- test_set %>% dplyr::select(name,close)  
bitcoin_cls_test <- bitcoin_cls_test %>% mutate(id = 1:nrow(bitcoin_cls_test))
res_df <- rbind(res_df,bitcoin_cls_test)

#Plot predicted vs actuals
res_df %>% 
  ggplot(aes(id,close,color = name)) + geom_line() + 
  theme_economist_white() +   
  labs(title = "Random Forest: Actuals vs Predicted",
       x = "id",
       y = "Price")

#Plot predicted vs actuals
#Create Dataframes for plotting 
res_df <- data.frame(name = "gamLoess", close = pred[,4], id = 1:nrow(test_set) )
bitcoin_cls_test <- test_set %>% dplyr::select(name,close)  
bitcoin_cls_test <- bitcoin_cls_test %>% mutate(id = 1:nrow(bitcoin_cls_test))
res_df <- rbind(res_df,bitcoin_cls_test)

#Plot predicted vs actuals
res_df %>% 
  ggplot(aes(id,close,color = name)) + geom_line() + 
  theme_economist_white() +   
  labs(title = "gamLoess: Actuals vs Predicted",
       x = "id",
       y = "Price")
```
### Model 2: Tuned gamLoess Model
The only two tuning parameters to tune the gamLoess model is the span and degree parameters. The optimal tuning parameters are as follows:

```{r,echo=FALSE}
set.seed(1, sample.kind="Rounding")
#Determine the best tuning parameter for degree = 2
span <- caret::train(close ~ market, method = "gamLoess",data = train_set,
                    span = data.frame(span = seq(0, 5, 0.1)))

span <- span$bestTune

kable_table(span, "Optimized Tuning Parameters")
```
Applying these tuning parameters, yields the following results:

```{r,echo=FALSE}
#Optimize span and degree
cvknn_fit <- caret::train(close ~ market, method = "gamLoess",data = train_set,
                          span = 0.5, degree = 1)

y_hat <- predict(cvknn_fit,test_set,type="raw")

#Plot Optimized gamLoess VS Actuals
#Create Dataframes for plotting 
res2_df <- data.frame(name = "gamLoess", close = y_hat, id = 1:nrow(test_set) )
res2_df <- rbind(res2_df,bitcoin_cls_test)

#Determine RMSE's
gl_opt_rmse <-  RMSE(y_hat,test_set$close)
rmse_results <- rmse_results %>% add_row(Dataset = "Train/Test", Model="Tuned gamLoess",RMSE = gl_opt_rmse)

#Print RMSE's
kable_table(rmse_results %>% filter(RMSE < 60),"RMSE of Tuned gamLoess Model")
```
\newpage
Plotting the actuals vs predicted values yields the following results:
```{r,echo=FALSE}
#Plot predicted vs actuals
res2_df %>% 
  ggplot(aes(id,close,color = name)) + geom_line() + geom_smooth(method = 'loess') + 
  theme_economist_white() +   
  labs(title = "Tuned gamLoess Model: Act vs Pred",
       x = "id",
       y = "Price")
```
The tuning parameters did not improve the RMSE which indicates that the train function has selected the optimal tuning parameters.

### Model 3: Tuned Random Forest Model

From the previous results, the random forest model can be tuned to possibly improve the RMSE by selecting 50 trees and determining the optimal mtry tuning parameter (in this case mtry was 19). The tuned RMSE is as follows:
```{r,echo=FALSE}
set.seed(1, sample.kind="Rounding")
#Determine the best tuning parameter for 100 trees
fit <- caret::train(close ~ market, method = "rf",data = train_set, ntree=50,
             tuneGrid = data.frame(mtry = seq(1, 20, 1)))

mtry <- fit$bestTune

#Print Optimal Tunegrid parameter
kable_table(fit$bestTune,"Optimal mtry Parameter for RF Model with 100 trees")

cvknn_fit <- caret::train(close ~ market, method = "rf",data = train_set,ntree=50,
                   tuneGrid = data.frame(mtry = mtry))

y_hat <- predict(cvknn_fit,test_set,type="raw")

#Determine RMSE's
rf_opt_rmse <-  RMSE(y_hat,test_set$close)
rmse_results <- rmse_results %>% add_row(Dataset = "Train/Test", Model="Tuned rf",RMSE = rf_opt_rmse)

#Print RMSE's
kable_table(rmse_results %>% filter(Model %like% "rf"),"RMSE of Tuned Random Forest Model")
```
\newpage
Plotting the actuals vs predicted values yields the following results:

```{r,echo=FALSE}
#Create Dataframes for plotting 
res3_df <- data.frame(name = "rf", close = y_hat, id = 1:nrow(test_set) )
res3_df <- rbind(res3_df,bitcoin_cls_test)


#Plot predicted vs actuals
res3_df %>% filter(id > 350) %>%
  ggplot(aes(id,close,color = name)) + geom_line() + geom_smooth(method = 'loess') +
  theme_economist_white() +   
  labs(title = "Tuned Random Forest: Act vs Pred",
       x = "id",
       y = "Price")
```
The tuning parameters did not improve the RMSE which indicates that the train function has selected the optimal tuning parameters.

### Model 4: ARIMA Model

“The AR part of ARIMA indicates that the evolving variable of interest is regressed on its own lagged (i.e., prior) values. The MA part indicates that the regression error is actually a linear combination of error terms whose values occurred contemporaneously and at various times in the past. The I (for “integrated”) indicates that the data values have been replaced with the difference between their values and the previous values (and this differencing process may have been performed more than once). The purpose of each of these features is to make the model fit the data as well as possible.”

The create the ARIMA model, a time-series object was created for the dataset. 

**The ARIMA model provides the following metrics**

- ME (Mean error): sum(et)/n
- MAE (Mean absolute error): sum(|et|)/n
- MPE (Mean percentage error): sum((et/Yt)*100)/n
- MAPE (Mean absolute percentage error): sum((|et|/Yt)*100)/n
- MSE (Mean squared error): sum(et*et)/n
- RMSE (Root of mean square error): sqrt(sum(et*et)/n)
- U (Theil’s U statistic): RMSE of the forecast/RMSE of the naive forecast
- [The Yt is ’observation series’. The Ft is ’Forecasting series’. The et is ’residual series’. The n is size of sample.]

The fitted results of the ARIMA model is shown below:

```{r,echo=FALSE}
##################################ARIMA Model##################################
set.seed(1, sample.kind="Rounding")
#Create Time-Series Object from Bitcoin Dataset
btc_timesrs <- ts(data_bitcoin$close)

#Build Arima Model 
autoarima <- auto.arima(btc_timesrs)

#Fit data with Arima
pred <-fitted(autoarima)

#Determine Mean-Absolute-Perecentage Error (MAPE)
#Evaluate the model using MAPE

fcast_auto_arima <- predict(autoarima, n.ahead = 4)
outdata <- data_bitcoin$close[29:32]

#Determine Model Fit

out_data_pred <- ts(fcast_auto_arima$pred)
total_timeser <- ts(data_bitcoin$close)

#Plot predicted vs actuals
plot(total_timeser, col = "black", lwd = 2)
lines(c(pred, out_data_pred), col = "blue", lwd = 2)
lines(pred, col="red", lwd = 2)
title("ARIMA: Actuals Vs Predicted");
```

Tuning the model with a set frequency and start date provide the following results:
```{r,echo=FALSE}
#Tune ARIMA model to include frequency and start date

count_ma = ts(data_bitcoin$close, frequency=365, start=c(2010,07))
arima = auto.arima(count_ma)
arima <- forecast(arima, h=2427)

#Print Optimized Results
acc_arima <- accuracy(arima)
kable_table(acc_arima,"ARIMA Results")

rmse_results <- rmse_results %>% add_row(Dataset = "Bitcoin", Model="Auto ARIMA",RMSE = acc_arima[,2])
```
The RMSE of the ARIMA model is 234.1335, which is substantially more than the gamLoess and random forest models.

\newpage
## Forecasting Future Values

This sections explores the different forecasting packages and their results using some well-known R-libraries for forecasting time-series data from previous data only. 

### General
**12 month Moving-Average**
The 12 month moving average shows a down-trend.
```{r,echo=FALSE}
#Create Time Series Data
plot_data <- ts(data_bitcoin %>% filter (priceYear > 2017)  %>% dplyr::select(close))

#Create Simple Moving Average
sm <- ma(plot_data , order=12) # 12 month moving average
plot(sm)
title("Moving Average of Bitcoin Price");
``` 
\newpage
**Naive Forecasting**

The accuracy of the model is defined by the Mean absolute scaled error (MASE) parameter, in this case it is 1.
```{r,echo=FALSE}
#Plot forecasting from naive method
mn <- naive(plot_data,h=12,level=c(90,95),fan=FALSE,lambda=NULL) 
plot(mn)
accuracy(mn)
``` 
\newpage
**Exponential Smoothing with Forecasting**

The accuracy of the model is defined by the MASE parameter, in this case it is 0.997011.
```{r,echo=FALSE}
#Plot forecasting from Exp Smoothing
plot(ses(plot_data))
accuracy(ses(plot_data))
``` 
\newpage
**Random Walk Drift Forecasting**

The accuracy of the model is defined by the MASE parameter, in this case it is 1.012579.
```{r,echo=FALSE}
#Plot Random Walk Drift
md <-rwf(plot_data,h=12,drift=T,level=c(90,95),fan=FALSE,lambda=NULL) 
plot(md) 
accuracy(md)
``` 
\newpage
**Holts Forecasting**

The accuracy of the model is defined by the MASE parameter, in this case it is 1.104114.
```{r,echo=FALSE}
#Plot forecasting from Holtwinters
m <- HoltWinters(plot_data, gamma = FALSE)
plot(forecast(m,h=80))
accuracy(forecast(m,h=80))
``` 
\newpage
**Thetha Forecasting**

The accuracy of the model is defined by the MASE parameter, in this case it is 0.997011.
```{r,echo=FALSE}
#Plot forecasting from Theta Method
plot(thetaf(plot_data))
accuracy(thetaf(plot_data))
``` 
\newpage
**Auto ARIMA**

The accuracy of the model is defined by the MASE parameter, in this case it is 1.008002. The ARIMA Errors graph indicates that there is limited randomness in the data.
```{r,echo=FALSE}
#Auto Arima
fit = auto.arima(plot_data)
tsdisplay(arima.errors(fit), main="ARIMA errors")
plot(forecast(fit))
accuracy(forecast(fit))
``` 

### Estimating Bitcoin Price

**Estimate Variance and Mean for next Day using Garch/ARIMA combination**

Using the Garch/Arima combination, the price variance and mean for the next day can be forecasted:
```{r,echo=FALSE}
#Calculate SSL series 
t<-ts(data_bitcoin[,"close"],start=1,frequency=5)
ln.t<-log(t) 
r<-diff(ln.t)
#Find a ARIMA model
fit1<-arima(r,order=c(4,0,0))
#Find a GARCH model 
res1<-resid(fit1) 
fit2<-garch(res1,order=c(2,1),trace=0)
#Forecasting 
kable_table(forecastGARCH(fit1,fit2,r=6), "Mean and Variance Forecast for next day")
``` 
\newpage
**Forecast price of Bitcoin for next year**

Using the ARIMA model, the price of Bitcoin can be estimated for the next year. The price window limits is between 1975 USD and 9580 USD.
```{r,echo=FALSE}
#Forecasting Bitcoin price using ARIMA
#Create Time Series Data
plot_data2 <- ts(data_bitcoin %>% dplyr::select(close))

y <- ts(plot_data2, frequency=7)
z <- fourier(ts(plot_data2, frequency=365.25), K=5)
zf <- fourierf(ts(plot_data2, frequency=365.25), K=5, h=100)
fit <- auto.arima(y)
fc <- forecast(fit, h=365)
plot(fc)
``` 
\newpage
# Results

**Models**

From the first set of models evaluated, which includes the glm, svmLinear, knn, gamLoess and rf methods, the gamLoess approach provided the best RMSE results. Tuning of both the random forest and gamLoess models did not improve the RMSE. Using the ARIMA model to model time-series data, the gamLoess model still offered a higher prediction accuracy.

**Final RMSE Results**
```{r,echo=FALSE}
#Print Final RMSE Results
kable_table(rmse_results,"RMSE of all Models")
```
**Forecasting**

From the several forecasting methods evaluated, the Exponential Smoothing and Thetha method forecasting provided the lowest MASE of 0.997011. This is less than 1, indicating that it is better than the naive forecasting method. The forecasting takes only only variable into consideration which can lead to inaccurate results in a volatile market.
\newpage

# Conclusion

This project offered a unique challenge due to the fact that the data was in univariate time-series format. The machine learning models evaluated provided adeqaute results for a start, but there is still a lot of optimization that can be done. The gamLoess model provided the best accuracy for this project.

Various forecasting libraries are available through the forecast package. The key is to select an appropriate evaluation parameter (in this case it was MASE). Future values can be forecasted within Lo and High bands (which indicates the possible forecasted window).

Based on the analyis performed, investment in Bitcoin is definitely viable. 

**For investement, the following however needs to be taken into account**

- Price volatility is extremely high
- No clear trading patterns exists for "high" days
- Forecasting future prices is extremely difficult just using previous prices. A model needs to be developed that takes various factors into account and not only the previous price.

**Recommendations**

- Research is important when working with different data formats to understand what is possible with a particular dataset.
- Spending time analyzing data before developing models/algorithms will help to achieve the goal faster.
- Although neural networks was not covered in this course, this can certainly be explored.
- Not all libraries/packages are working when researching what peers have done. Rather start with first principle analysis

**Future Work**

- Use the Long Short-Term Memory (LSTM) Recurrent Neural Network (RNN) methodology to explore this project further. 
- Develop a realtime system by linking with API's from different exchanges.
- Consider time and seasonal effects in more detail. 
- Use more methods in the caret package to evaluate RSME.
- Incorporate more variables in future price predication.

\newpage
# References
https://en.wikipedia.org/wiki/Cryptocurrency

https://en.wikipedia.org/wiki/Stock_market

https://steemit.com/cryptocurrency/@gmichelbkk/what-problems-do-cryptocurrencies-solve

https://pkg.robjhyndman.com/forecast/

https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/decompose

https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/ts

https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average

https://a-little-book-of-r-for-time-series.readthedocs.io/en/latest/src/timeseries.html

https://blog.newrelic.com/engineering/performance-metrics-in-time-series-data/

https://www.dummies.com/programming/big-data/data-science/univariate-time-series-data/

https://www.analyticsvidhya.com/blog/2018/09/multivariate-time-series-guide-forecasting-modeling-python-codes/

https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average

https://www.itl.nist.gov/div898/handbook/eda/section3/autocopl.htm

https://blogs.oracle.com/datascience/7-ways-time-series-forecasting-differs-from-machine-learning

https://github.com/sfeuerriegel/caret.ts

http://topepo.github.io/caret/train-models-by-tag.html

https://cran.r-project.org/web/packages/AnalyzeTS/AnalyzeTS.pdf

http://r-statistics.co/Time-Series-Analysis-With-R.html

https://bookdown.org/yihui/rmarkdown/

https://www.r-bloggers.com/time-series-analysis-using-r-forecast-package/

\newpage
# Environmental Variables

```{r}
#Print OS
print("Operating System:")
version

#Print Installed Packages
print("All installed packages")
installed.packages()
```